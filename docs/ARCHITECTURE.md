# Архитектура Log Owl

Этот документ для тех, кто смотрит на **Log Owl** как на пример архитектуры desktop‑приложения: как разделены слои, как устроен IPC, как используются миграции БД и quality‑gate.

- Общее описание проекта и как его запустить — в `README.md`.
- Подробный setup для разработки (dev‑скрипты, стиль кода) — в `docs/DEV-SETUP.md`.
- Информация о сборке инсталляторов — в `docs/BUILD.md`.

---

## Высокоуровневая архитектура

Проект разделён на несколько слоёв:

- **`main/`** — Electron main‑процесс:
  - инициализация приложения и окон;
  - работа с БД и миграциями;
  - регистрация IPC‑каналов;
  - инфраструктурные утилиты (логирование, обработка ошибок).
- **`renderer/`** — React‑приложение:
  - страницы и маршруты;
  - общие UI‑компоненты (на базе MUI);
  - хранилища состояния (Zustand);
  - клиент для обращения к IPC‑методам через типизированные контракты.
- **`contracts/`** — общие типы и контракты IPC между main и renderer.
- **`scripts/`** — вспомогательные скрипты (например, генерация каналов preload).

Основные принципы:

- разделение ответственности между main и renderer;
- строгая типизация и валидация на границах слоёв;
- минимум «магии» в конфигурации — всё завязано на понятные скрипты `package.json`.

---

## IPC и контракты

IPC между main и renderer построен вокруг:

- общего пакета `contracts` для типов и контрактов (например, обёрток вида `IpcResponse`);
- обёрток в main‑процессе, которые:
  - принимают `channel` и хендлер;
  - при необходимости валидируют аргументы через **Zod**;
  - возвращают унифицированный ответ:
    - `{ ok: true, data }` при успехе;
    - `{ ok: false, error }` при ошибке.

Это даёт:

- типобезопасность на границе main/renderer;
- единый формат обработки ошибок в UI;
- централизованный лог ошибок в main.

При добавлении нового IPC‑метода типичный сценарий выглядит так:

1. Добавить/обновить типы в `contracts/`.
2. Зарегистрировать хендлер в `main/ipc/...` через обёртку (например, `handleIpc` или `validateAndHandle`).
3. В renderer использовать соответствующий контракт/тип ответа.

---

## Работа с БД и миграциями

За хранение данных отвечает **SQLite** через `better-sqlite3`:

- схема и миграции находятся в `main/migrations`;
- запуск и применение миграций происходят на старте приложения в main‑процессе;
- репозитории инкапсулируют доступ к таблицам и инварианты домена.

Подход:

- миграции версионируются и применяются последовательно;
- структура БД эволюционирует через добавление миграций, а не «ручное» изменение схемы;
- часть инвариантов (например, каскадное удаление) может быть реализована либо в SQL (через `FOREIGN KEY ... ON DELETE CASCADE`), либо в коде репозиториев — это явно документируется.

---

## Импорты и границы слоёв

Для управления зависимостями между слоями используются алиасы (см. `tsconfig.base.json` и `vite.config.ts`):

- `@main/...` — код main‑процесса;
- `@renderer/...` — код renderer;
- `@contracts` — общие контракты/типы.

Это помогает:

- избегать глубоких относительных импортов (`../../../`);
- визуально считать, откуда приходит зависимость;
- проще менять структуру каталогов без массовых правок импортов.

Рекомендация:

- UI‑код (`renderer`) не ходит напрямую в БД — только через IPC и контракты;
- main‑код не импортирует React‑компоненты;
- общие типы живут в `contracts` и не тянут за собой UI‑или инфраструктурные зависимости.

---

## Качество кода и CI как часть архитектуры

Архитектурные решения подкреплены цепочкой quality‑gate:

- **TypeScript strict mode** — жёсткая типизация на всём проекте.
- **ESLint + Prettier + CSpell** — единые правила стиля и форматирования, проверка орфографии (включая русский словарь).
- **Vitest** — юнит‑тесты для бизнес‑логики, утилит и части Electron‑кода. **Покрытие кода измеряется (Vitest Coverage, провайдер v8)**; в проверках (pre-commit и CI) используется прогон с покрытием и **низким порогом**, чтобы регрессии покрытия были видны.
- **Husky + lint-staged**:
  - на pre-commit гоняются линтер, форматтер, spellcheck и тесты с покрытием только по изменённым файлам;
  - большинство проблем ловится до пуша.
- **GitHub Actions**:
  - `.github/workflows/ci.yml` — общий `pnpm run check` на pull request и push в основную ветку;
  - `.github/workflows/release.yml` — сборка инсталляторов и публикация в Releases по тэгу.

Таким образом:

- архитектура не ограничивается разбиением по папкам;
- цепочка проверок и CI — часть договорённостей по качеству и поддерживаемости проекта.
